// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: chat_message.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createChatMessage = `-- name: CreateChatMessage :one
INSERT INTO chat_messages
(room_id, user_id, content, status, is_read, type_message)
VALUES
($1, $2, $3, true, false, $4)
RETURNING id, room_id, user_id, content, status, reply_id, read_at, is_read, created_at, updated_at, type_message, is_accepted
`

type CreateChatMessageParams struct {
	RoomID      sql.NullInt64  `json:"room_id"`
	UserID      sql.NullInt64  `json:"user_id"`
	Content     string         `json:"content"`
	TypeMessage sql.NullString `json:"type_message"`
}

func (q *Queries) CreateChatMessage(ctx context.Context, arg CreateChatMessageParams) (ChatMessage, error) {
	row := q.db.QueryRowContext(ctx, createChatMessage,
		arg.RoomID,
		arg.UserID,
		arg.Content,
		arg.TypeMessage,
	)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.RoomID,
		&i.UserID,
		&i.Content,
		&i.Status,
		&i.ReplyID,
		&i.ReadAt,
		&i.IsRead,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TypeMessage,
		&i.IsAccepted,
	)
	return i, err
}

const getChatMessagesByRoomId = `-- name: GetChatMessagesByRoomId :many
SELECT m.id, m.room_id, m.user_id, m.content, m.status, m.reply_id, m.read_at, m.is_read, m.created_at, m.updated_at, m.type_message, m.is_accepted, u.name, u.profile_picture
FROM public.chat_messages m JOIN users u on m.user_id = u.id
JOIN chat_rooms r on r.id = m.room_id AND (r.advertisement_user_id = $2 OR r.interested_user_id = $2)
WHERE m.room_id = $1
ORDER BY m.created_at ASC
`

type GetChatMessagesByRoomIdParams struct {
	RoomID sql.NullInt64 `json:"room_id"`
	UserID int64         `json:"user_id"`
}

type GetChatMessagesByRoomIdRow struct {
	ID             int64          `json:"id"`
	RoomID         sql.NullInt64  `json:"room_id"`
	UserID         sql.NullInt64  `json:"user_id"`
	Content        string         `json:"content"`
	Status         bool           `json:"status"`
	ReplyID        sql.NullInt64  `json:"reply_id"`
	ReadAt         sql.NullTime   `json:"read_at"`
	IsRead         sql.NullBool   `json:"is_read"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
	TypeMessage    sql.NullString `json:"type_message"`
	IsAccepted     sql.NullBool   `json:"is_accepted"`
	Name           string         `json:"name"`
	ProfilePicture sql.NullString `json:"profile_picture"`
}

func (q *Queries) GetChatMessagesByRoomId(ctx context.Context, arg GetChatMessagesByRoomIdParams) ([]GetChatMessagesByRoomIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getChatMessagesByRoomId, arg.RoomID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChatMessagesByRoomIdRow
	for rows.Next() {
		var i GetChatMessagesByRoomIdRow
		if err := rows.Scan(
			&i.ID,
			&i.RoomID,
			&i.UserID,
			&i.Content,
			&i.Status,
			&i.ReplyID,
			&i.ReadAt,
			&i.IsRead,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TypeMessage,
			&i.IsAccepted,
			&i.Name,
			&i.ProfilePicture,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastMessageByRoomId = `-- name: GetLastMessageByRoomId :many
SELECT m.id, m.room_id, m.user_id, m.content, m.status, m.reply_id, m.read_at, m.is_read, m.created_at, m.updated_at, m.type_message, m.is_accepted, u.name, u.profile_picture from chat_messages m
JOIN users u on m.user_id = u.id
JOIN chat_rooms r on r.id = m.room_id AND (r.advertisement_user_id = $1 OR r.interested_user_id = $1)
ORDER BY m.created_at DESC
LIMIT 1
`

type GetLastMessageByRoomIdRow struct {
	ID             int64          `json:"id"`
	RoomID         sql.NullInt64  `json:"room_id"`
	UserID         sql.NullInt64  `json:"user_id"`
	Content        string         `json:"content"`
	Status         bool           `json:"status"`
	ReplyID        sql.NullInt64  `json:"reply_id"`
	ReadAt         sql.NullTime   `json:"read_at"`
	IsRead         sql.NullBool   `json:"is_read"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
	TypeMessage    sql.NullString `json:"type_message"`
	IsAccepted     sql.NullBool   `json:"is_accepted"`
	Name           string         `json:"name"`
	ProfilePicture sql.NullString `json:"profile_picture"`
}

func (q *Queries) GetLastMessageByRoomId(ctx context.Context, userID int64) ([]GetLastMessageByRoomIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getLastMessageByRoomId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLastMessageByRoomIdRow
	for rows.Next() {
		var i GetLastMessageByRoomIdRow
		if err := rows.Scan(
			&i.ID,
			&i.RoomID,
			&i.UserID,
			&i.Content,
			&i.Status,
			&i.ReplyID,
			&i.ReadAt,
			&i.IsRead,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TypeMessage,
			&i.IsAccepted,
			&i.Name,
			&i.ProfilePicture,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoomByMessageId = `-- name: GetRoomByMessageId :one
SELECT r.id, r.advertisement_id, r.advertisement_user_id, r.interested_user_id, r.status, r.created_at, r.updated_at, m.type_message, m.is_accepted FROM chat_messages m
JOIN chat_rooms r ON r.id = m.room_id
WHERE m.id = $1
`

type GetRoomByMessageIdRow struct {
	ID                  int64          `json:"id"`
	AdvertisementID     int64          `json:"advertisement_id"`
	AdvertisementUserID int64          `json:"advertisement_user_id"`
	InterestedUserID    int64          `json:"interested_user_id"`
	Status              bool           `json:"status"`
	CreatedAt           time.Time      `json:"created_at"`
	UpdatedAt           sql.NullTime   `json:"updated_at"`
	TypeMessage         sql.NullString `json:"type_message"`
	IsAccepted          sql.NullBool   `json:"is_accepted"`
}

func (q *Queries) GetRoomByMessageId(ctx context.Context, id int64) (GetRoomByMessageIdRow, error) {
	row := q.db.QueryRowContext(ctx, getRoomByMessageId, id)
	var i GetRoomByMessageIdRow
	err := row.Scan(
		&i.ID,
		&i.AdvertisementID,
		&i.AdvertisementUserID,
		&i.InterestedUserID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TypeMessage,
		&i.IsAccepted,
	)
	return i, err
}

const getUnreadMessagesCount = `-- name: GetUnreadMessagesCount :one
SELECT COALESCE(
    SUM(CASE WHEN m.is_read = FALSE AND m.user_id <> $1 THEN 1 ELSE 0 END), 
    0
)::bigint AS unread_count
FROM chat_rooms r
JOIN chat_messages m ON m.room_id = r.id
WHERE (r.advertisement_user_id = $1 OR r.interested_user_id = $1)
`

func (q *Queries) GetUnreadMessagesCount(ctx context.Context, userID sql.NullInt64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUnreadMessagesCount, userID)
	var unread_count int64
	err := row.Scan(&unread_count)
	return unread_count, err
}

const readMessages = `-- name: ReadMessages :one
UPDATE chat_messages
SET is_read = true, read_at = now() 
WHERE user_id != $1
AND room_id = $2
RETURNING read_at
`

type ReadMessagesParams struct {
	UserID sql.NullInt64 `json:"user_id"`
	RoomID sql.NullInt64 `json:"room_id"`
}

func (q *Queries) ReadMessages(ctx context.Context, arg ReadMessagesParams) (sql.NullTime, error) {
	row := q.db.QueryRowContext(ctx, readMessages, arg.UserID, arg.RoomID)
	var read_at sql.NullTime
	err := row.Scan(&read_at)
	return read_at, err
}

const updateMessageStatus = `-- name: UpdateMessageStatus :exec
UPDATE chat_messages
SET is_accepted = $1
WHERE id = $2
`

type UpdateMessageStatusParams struct {
	IsAccepted sql.NullBool `json:"is_accepted"`
	ID         int64        `json:"id"`
}

func (q *Queries) UpdateMessageStatus(ctx context.Context, arg UpdateMessageStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateMessageStatus, arg.IsAccepted, arg.ID)
	return err
}
