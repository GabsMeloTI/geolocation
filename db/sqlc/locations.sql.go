// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.0
// source: locations.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createArea = `-- name: CreateArea :one
INSERT INTO public.areas
(id, locations_id, latitude, longitude, description, created_at)
VALUES(nextval('areas_id_seq'::regclass), $1, $2, $3, $4, now())
    RETURNING id, locations_id, latitude, longitude, description, created_at, updated_at
`

type CreateAreaParams struct {
	LocationsID int64  `json:"locations_id"`
	Latitude    string `json:"latitude"`
	Longitude   string `json:"longitude"`
	Description string `json:"description"`
}

func (q *Queries) CreateArea(ctx context.Context, arg CreateAreaParams) (Area, error) {
	row := q.db.QueryRowContext(ctx, createArea,
		arg.LocationsID,
		arg.Latitude,
		arg.Longitude,
		arg.Description,
	)
	var i Area
	err := row.Scan(
		&i.ID,
		&i.LocationsID,
		&i.Latitude,
		&i.Longitude,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createLocation = `-- name: CreateLocation :one
INSERT INTO public.locations
(id, "type", address, id_provider_info, color, created_at, access_id, tenant_id)
VALUES(nextval('locations_id_seq'::regclass), $1, $2, $3, $4, now(), $5, $6)
    RETURNING id, type, address, id_provider_info, color, created_at, updated_at, access_id, tenant_id
`

type CreateLocationParams struct {
	Type           string         `json:"type"`
	Address        sql.NullString `json:"address"`
	IDProviderInfo int64          `json:"id_provider_info"`
	Color          string         `json:"color"`
	AccessID       int64          `json:"access_id"`
	TenantID       uuid.UUID      `json:"tenant_id"`
}

func (q *Queries) CreateLocation(ctx context.Context, arg CreateLocationParams) (Location, error) {
	row := q.db.QueryRowContext(ctx, createLocation,
		arg.Type,
		arg.Address,
		arg.IDProviderInfo,
		arg.Color,
		arg.AccessID,
		arg.TenantID,
	)
	var i Location
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Address,
		&i.IDProviderInfo,
		&i.Color,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccessID,
		&i.TenantID,
	)
	return i, err
}

const deleteArea = `-- name: DeleteArea :exec
DELETE FROM public.areas
WHERE locations_id=$1
`

func (q *Queries) DeleteArea(ctx context.Context, locationsID int64) error {
	_, err := q.db.ExecContext(ctx, deleteArea, locationsID)
	return err
}

const deleteLocation = `-- name: DeleteLocation :exec
DELETE FROM public.locations
WHERE id=$1 AND
    access_id=$2 AND
    tenant_id=$3
`

type DeleteLocationParams struct {
	ID       int64     `json:"id"`
	AccessID int64     `json:"access_id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteLocation(ctx context.Context, arg DeleteLocationParams) error {
	_, err := q.db.ExecContext(ctx, deleteLocation, arg.ID, arg.AccessID, arg.TenantID)
	return err
}

const getAreasByOrg = `-- name: GetAreasByOrg :many
SELECT a.id, a.locations_id, a.latitude, a.longitude, a.description
FROM public.areas a
WHERE locations_id=$1
`

type GetAreasByOrgRow struct {
	ID          int64  `json:"id"`
	LocationsID int64  `json:"locations_id"`
	Latitude    string `json:"latitude"`
	Longitude   string `json:"longitude"`
	Description string `json:"description"`
}

func (q *Queries) GetAreasByOrg(ctx context.Context, locationsID int64) ([]GetAreasByOrgRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreasByOrg, locationsID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreasByOrgRow
	for rows.Next() {
		var i GetAreasByOrgRow
		if err := rows.Scan(
			&i.ID,
			&i.LocationsID,
			&i.Latitude,
			&i.Longitude,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocationByName = `-- name: GetLocationByName :many
SELECT id, type, address, id_provider_info, color, created_at, updated_at, access_id, tenant_id
FROM public.locations l
WHERE id_provider_info=$3 AND
      type=$4 AND
      access_id=$1 AND
      tenant_id=$2
`

type GetLocationByNameParams struct {
	AccessID       int64     `json:"access_id"`
	TenantID       uuid.UUID `json:"tenant_id"`
	IDProviderInfo int64     `json:"id_provider_info"`
	Type           string    `json:"type"`
}

func (q *Queries) GetLocationByName(ctx context.Context, arg GetLocationByNameParams) ([]Location, error) {
	rows, err := q.db.QueryContext(ctx, getLocationByName,
		arg.AccessID,
		arg.TenantID,
		arg.IDProviderInfo,
		arg.Type,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Location
	for rows.Next() {
		var i Location
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Address,
			&i.IDProviderInfo,
			&i.Color,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccessID,
			&i.TenantID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocationByNameExcludingID = `-- name: GetLocationByNameExcludingID :one
SELECT id, type, address, id_provider_info, color, created_at, updated_at, access_id, tenant_id
FROM public.locations
WHERE access_id  = $1
  AND tenant_id  = $2
  AND type      = $3
  AND id         <> $4
  AND id_provider_info = $5
`

type GetLocationByNameExcludingIDParams struct {
	AccessID       int64     `json:"access_id"`
	TenantID       uuid.UUID `json:"tenant_id"`
	Type           string    `json:"type"`
	ID             int64     `json:"id"`
	IDProviderInfo int64     `json:"id_provider_info"`
}

func (q *Queries) GetLocationByNameExcludingID(ctx context.Context, arg GetLocationByNameExcludingIDParams) (Location, error) {
	row := q.db.QueryRowContext(ctx, getLocationByNameExcludingID,
		arg.AccessID,
		arg.TenantID,
		arg.Type,
		arg.ID,
		arg.IDProviderInfo,
	)
	var i Location
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Address,
		&i.IDProviderInfo,
		&i.Color,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccessID,
		&i.TenantID,
	)
	return i, err
}

const getLocationByOrg = `-- name: GetLocationByOrg :many
SELECT l.id, l.type, l.address, l.id_provider_info, l.color, l.created_at, l.updated_at, l.access_id, l.tenant_id
FROM public.locations l
WHERE id_provider_info=$3 AND
      access_id=$1 AND
      tenant_id=$2
`

type GetLocationByOrgParams struct {
	AccessID       int64     `json:"access_id"`
	TenantID       uuid.UUID `json:"tenant_id"`
	IDProviderInfo int64     `json:"id_provider_info"`
}

func (q *Queries) GetLocationByOrg(ctx context.Context, arg GetLocationByOrgParams) ([]Location, error) {
	rows, err := q.db.QueryContext(ctx, getLocationByOrg, arg.AccessID, arg.TenantID, arg.IDProviderInfo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Location
	for rows.Next() {
		var i Location
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Address,
			&i.IDProviderInfo,
			&i.Color,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccessID,
			&i.TenantID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateArea = `-- name: UpdateArea :one
UPDATE public.areas
SET locations_id=$1, latitude=$2, longitude=$3, description=$4, created_at=now()
WHERE id=$5
    RETURNING id, locations_id, latitude, longitude, description, created_at, updated_at
`

type UpdateAreaParams struct {
	LocationsID int64  `json:"locations_id"`
	Latitude    string `json:"latitude"`
	Longitude   string `json:"longitude"`
	Description string `json:"description"`
	ID          int64  `json:"id"`
}

func (q *Queries) UpdateArea(ctx context.Context, arg UpdateAreaParams) (Area, error) {
	row := q.db.QueryRowContext(ctx, updateArea,
		arg.LocationsID,
		arg.Latitude,
		arg.Longitude,
		arg.Description,
		arg.ID,
	)
	var i Area
	err := row.Scan(
		&i.ID,
		&i.LocationsID,
		&i.Latitude,
		&i.Longitude,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLocation = `-- name: UpdateLocation :one
UPDATE public.locations
SET "type"=$1, address=$2, id_provider_info=$6, color=$7, updated_at=now()
WHERE id=$3 AND
    access_id=$4 AND
    tenant_id=$5
    RETURNING id, type, address, id_provider_info, color, created_at, updated_at, access_id, tenant_id
`

type UpdateLocationParams struct {
	Type           string         `json:"type"`
	Address        sql.NullString `json:"address"`
	ID             int64          `json:"id"`
	AccessID       int64          `json:"access_id"`
	TenantID       uuid.UUID      `json:"tenant_id"`
	IDProviderInfo int64          `json:"id_provider_info"`
	Color          string         `json:"color"`
}

func (q *Queries) UpdateLocation(ctx context.Context, arg UpdateLocationParams) (Location, error) {
	row := q.db.QueryRowContext(ctx, updateLocation,
		arg.Type,
		arg.Address,
		arg.ID,
		arg.AccessID,
		arg.TenantID,
		arg.IDProviderInfo,
		arg.Color,
	)
	var i Location
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Address,
		&i.IDProviderInfo,
		&i.Color,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccessID,
		&i.TenantID,
	)
	return i, err
}
