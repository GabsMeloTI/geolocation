// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.0
// source: dashboard.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const getDashboardCalendar = `-- name: GetDashboardCalendar :many
SELECT
    a.user_id,
    a.id AS advertisement_id,
    ap.id AS appointments_id,
    a.pickup_date,
    ap.situation
FROM appointments ap
         INNER JOIN advertisement a ON a.id = ap.advertisement_id
WHERE a.user_id = $1
ORDER BY a.pickup_date ASC
`

type GetDashboardCalendarRow struct {
	UserID          int64     `json:"user_id"`
	AdvertisementID int64     `json:"advertisement_id"`
	AppointmentsID  int64     `json:"appointments_id"`
	PickupDate      time.Time `json:"pickup_date"`
	Situation       string    `json:"situation"`
}

func (q *Queries) GetDashboardCalendar(ctx context.Context, userID int64) ([]GetDashboardCalendarRow, error) {
	rows, err := q.db.QueryContext(ctx, getDashboardCalendar, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDashboardCalendarRow
	for rows.Next() {
		var i GetDashboardCalendarRow
		if err := rows.Scan(
			&i.UserID,
			&i.AdvertisementID,
			&i.AppointmentsID,
			&i.PickupDate,
			&i.Situation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDashboardDriver = `-- name: GetDashboardDriver :one
WITH faturamento_mensal AS (
    SELECT
        ap.interested_user_id,
        EXTRACT(YEAR FROM a.delivery_date) AS ano,
        EXTRACT(MONTH FROM a.delivery_date) AS mes,
        SUM(a.price::float8) AS total_faturado
    FROM appointments ap
             INNER JOIN advertisement a ON a.id = ap.advertisement_id
    WHERE ap.situation = 'finalizado'
    GROUP BY ap.interested_user_id,
             EXTRACT(YEAR FROM a.delivery_date),
             EXTRACT(MONTH FROM a.delivery_date)
)
SELECT
    u.id AS user_id,
    d.id AS driver_id,
    COALESCE(
            SUM(
                    CASE
                        WHEN ap.situation = 'finalizado'
                            AND EXTRACT(MONTH FROM a.delivery_date) = EXTRACT(MONTH FROM CURRENT_DATE)
                            AND EXTRACT(YEAR FROM a.delivery_date) = EXTRACT(YEAR FROM CURRENT_DATE)
                            THEN a.price::float8
                        ELSE 0::float8
                        END
            ), 0::float8
    )::float8 AS total_fretes_finalizados_mes_atual,
    COALESCE(
            SUM(
                    CASE
                        WHEN ap.situation != 'finalizado'
                        AND EXTRACT(MONTH FROM a.delivery_date) = EXTRACT(MONTH FROM CURRENT_DATE)
                        AND EXTRACT(YEAR FROM a.delivery_date) = EXTRACT(YEAR FROM CURRENT_DATE)
                    THEN a.price::float8
                    ELSE 0::float8
                    END
            ), 0::float8
    )::float8 AS total_a_receber_mes_atual,
    COUNT(
            DISTINCT CASE
                         WHEN ap.situation = 'finalizado'
                             AND EXTRACT(MONTH FROM a.delivery_date) = EXTRACT(MONTH FROM CURRENT_DATE)
                             AND EXTRACT(YEAR FROM a.delivery_date) = EXTRACT(YEAR FROM CURRENT_DATE)
                             THEN ap.advertisement_user_id
        END
    ) AS clientes_atendidos_mes_atual,
    COALESCE(
            SUM(
                    CASE
                        WHEN ap.situation = 'finalizado'
                            AND EXTRACT(MONTH FROM a.delivery_date) = CASE WHEN EXTRACT(MONTH FROM CURRENT_DATE) = 1 THEN 12 ELSE EXTRACT(MONTH FROM CURRENT_DATE) - 1 END
                            AND EXTRACT(YEAR FROM a.delivery_date) = CASE WHEN EXTRACT(MONTH FROM CURRENT_DATE) = 1 THEN EXTRACT(YEAR FROM CURRENT_DATE) - 1 ELSE EXTRACT(YEAR FROM CURRENT_DATE) END
                            THEN a.price::float8
                        ELSE 0::float8
                        END
            ), 0::float8
    )::float8 AS total_fretes_finalizados_mes_anterior,
    COUNT(
            DISTINCT CASE
                         WHEN ap.situation = 'finalizado'
                             AND EXTRACT(MONTH FROM a.delivery_date) = CASE WHEN EXTRACT(MONTH FROM CURRENT_DATE) = 1 THEN 12 ELSE EXTRACT(MONTH FROM CURRENT_DATE) - 1 END
                             AND EXTRACT(YEAR FROM a.delivery_date) = CASE WHEN EXTRACT(MONTH FROM CURRENT_DATE) = 1 THEN EXTRACT(YEAR FROM CURRENT_DATE) - 1 ELSE EXTRACT(YEAR FROM CURRENT_DATE) END
                             THEN ap.advertisement_user_id
        END
    ) AS clientes_atendidos_mes_anterior
FROM users u
         INNER JOIN driver d ON d.user_id = u.id
         INNER JOIN appointments ap ON ap.interested_user_id = u.id
         INNER JOIN advertisement a ON a.id = ap.advertisement_id
         LEFT JOIN faturamento_mensal fm ON fm.interested_user_id = u.id
WHERE u.id = $1
GROUP BY u.id, d.id
`

type GetDashboardDriverRow struct {
	UserID                            int64   `json:"user_id"`
	DriverID                          int64   `json:"driver_id"`
	TotalFretesFinalizadosMesAtual    float64 `json:"total_fretes_finalizados_mes_atual"`
	TotalAReceberMesAtual             float64 `json:"total_a_receber_mes_atual"`
	ClientesAtendidosMesAtual         int64   `json:"clientes_atendidos_mes_atual"`
	TotalFretesFinalizadosMesAnterior float64 `json:"total_fretes_finalizados_mes_anterior"`
	ClientesAtendidosMesAnterior      int64   `json:"clientes_atendidos_mes_anterior"`
}

func (q *Queries) GetDashboardDriver(ctx context.Context, id int64) (GetDashboardDriverRow, error) {
	row := q.db.QueryRowContext(ctx, getDashboardDriver, id)
	var i GetDashboardDriverRow
	err := row.Scan(
		&i.UserID,
		&i.DriverID,
		&i.TotalFretesFinalizadosMesAtual,
		&i.TotalAReceberMesAtual,
		&i.ClientesAtendidosMesAtual,
		&i.TotalFretesFinalizadosMesAnterior,
		&i.ClientesAtendidosMesAnterior,
	)
	return i, err
}

const getDashboardDriverEnterprise = `-- name: GetDashboardDriverEnterprise :many
select d.id, d.name, d.license_number,  d.license_category,
       CASE
           WHEN EXISTS (
               SELECT 1
               FROM truck t
                        JOIN appointments a ON t.id = a.truck_id
               WHERE t.driver_id = d.id
                 AND a.situation = 'em andamento'
           ) THEN 'em viagem'
           ELSE 'disponivel'
           END AS disponibilidade
FROM driver d
WHERE d.user_id = $1
`

type GetDashboardDriverEnterpriseRow struct {
	ID              int64  `json:"id"`
	Name            string `json:"name"`
	LicenseNumber   string `json:"license_number"`
	LicenseCategory string `json:"license_category"`
	Disponibilidade string `json:"disponibilidade"`
}

func (q *Queries) GetDashboardDriverEnterprise(ctx context.Context, userID int64) ([]GetDashboardDriverEnterpriseRow, error) {
	rows, err := q.db.QueryContext(ctx, getDashboardDriverEnterprise, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDashboardDriverEnterpriseRow
	for rows.Next() {
		var i GetDashboardDriverEnterpriseRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.LicenseNumber,
			&i.LicenseCategory,
			&i.Disponibilidade,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDashboardFaturamento = `-- name: GetDashboardFaturamento :many
WITH faturamento_mensal AS (
    SELECT
        ap.interested_user_id,
        EXTRACT(YEAR FROM ap.created_at)::bigint AS ano,
            EXTRACT(MONTH FROM ap.created_at)::bigint AS mes,
            SUM(a.price)::float8 AS total_faturado
    FROM appointments ap
             INNER JOIN advertisement a ON a.id = ap.advertisement_id
    WHERE ap.situation = 'finalizado'
    GROUP BY ap.interested_user_id,
             EXTRACT(YEAR FROM ap.created_at),
             EXTRACT(MONTH FROM ap.created_at)
)
SELECT
    ano,
    mes,
    total_faturado
FROM faturamento_mensal
WHERE interested_user_id = $1
ORDER BY ano DESC, mes DESC
`

type GetDashboardFaturamentoRow struct {
	Ano           int64   `json:"ano"`
	Mes           int64   `json:"mes"`
	TotalFaturado float64 `json:"total_faturado"`
}

func (q *Queries) GetDashboardFaturamento(ctx context.Context, interestedUserID int64) ([]GetDashboardFaturamentoRow, error) {
	rows, err := q.db.QueryContext(ctx, getDashboardFaturamento, interestedUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDashboardFaturamentoRow
	for rows.Next() {
		var i GetDashboardFaturamentoRow
		if err := rows.Scan(&i.Ano, &i.Mes, &i.TotalFaturado); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDashboardFuture = `-- name: GetDashboardFuture :many
SELECT
    a.user_id,
    a.id AS advertisement_id,
    a.origin AS lembretes_origin,
    a.destination AS lembretes_destination,
    a.pickup_date AS lembretes_pickup_date
FROM advertisement a
WHERE a.user_id = $1 AND a.pickup_date > NOW()
GROUP BY a.id, a.user_id, a.origin, a.destination, a.pickup_date
ORDER BY a.pickup_date ASC
`

type GetDashboardFutureRow struct {
	UserID               int64     `json:"user_id"`
	AdvertisementID      int64     `json:"advertisement_id"`
	LembretesOrigin      string    `json:"lembretes_origin"`
	LembretesDestination string    `json:"lembretes_destination"`
	LembretesPickupDate  time.Time `json:"lembretes_pickup_date"`
}

func (q *Queries) GetDashboardFuture(ctx context.Context, userID int64) ([]GetDashboardFutureRow, error) {
	rows, err := q.db.QueryContext(ctx, getDashboardFuture, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDashboardFutureRow
	for rows.Next() {
		var i GetDashboardFutureRow
		if err := rows.Scan(
			&i.UserID,
			&i.AdvertisementID,
			&i.LembretesOrigin,
			&i.LembretesDestination,
			&i.LembretesPickupDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDashboardHist = `-- name: GetDashboardHist :many
SELECT
    adv.name AS historico_user_name,
    a.id AS historico_frete_id,
    a.delivery_date AS historico_delivery_date,
    a.price AS historico_price
FROM users u
         INNER JOIN driver d ON d.user_id = u.id
         INNER JOIN appointments ap ON ap.interested_user_id = u.id
         INNER JOIN advertisement a ON a.id = ap.advertisement_id
         INNER JOIN users adv ON adv.id = ap.advertisement_user_id
WHERE u.id = $1 AND ap.situation = 'finalizado'
GROUP BY adv.name, a.id, a.delivery_date, a.price
`

type GetDashboardHistRow struct {
	HistoricoUserName     string    `json:"historico_user_name"`
	HistoricoFreteID      int64     `json:"historico_frete_id"`
	HistoricoDeliveryDate time.Time `json:"historico_delivery_date"`
	HistoricoPrice        float64   `json:"historico_price"`
}

func (q *Queries) GetDashboardHist(ctx context.Context, id int64) ([]GetDashboardHistRow, error) {
	rows, err := q.db.QueryContext(ctx, getDashboardHist, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDashboardHistRow
	for rows.Next() {
		var i GetDashboardHistRow
		if err := rows.Scan(
			&i.HistoricoUserName,
			&i.HistoricoFreteID,
			&i.HistoricoDeliveryDate,
			&i.HistoricoPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDashboardTractUnitEnterprise = `-- name: GetDashboardTractUnitEnterprise :many
SELECT DISTINCT tu.id, tu.model, tu.unit_type, tu.capacity
FROM tractor_unit tu
         LEFT JOIN truck t ON tu.id = t.tractor_unit_id
         LEFT JOIN appointments a ON t.id = a.truck_id
WHERE tu.user_id = $1
  AND (a.situation != 'em andamento' OR a.situation IS NULL)
`

type GetDashboardTractUnitEnterpriseRow struct {
	ID       int64          `json:"id"`
	Model    string         `json:"model"`
	UnitType sql.NullString `json:"unit_type"`
	Capacity string         `json:"capacity"`
}

func (q *Queries) GetDashboardTractUnitEnterprise(ctx context.Context, userID int64) ([]GetDashboardTractUnitEnterpriseRow, error) {
	rows, err := q.db.QueryContext(ctx, getDashboardTractUnitEnterprise, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDashboardTractUnitEnterpriseRow
	for rows.Next() {
		var i GetDashboardTractUnitEnterpriseRow
		if err := rows.Scan(
			&i.ID,
			&i.Model,
			&i.UnitType,
			&i.Capacity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDashboardTrailerEnterprise = `-- name: GetDashboardTrailerEnterprise :many
SELECT DISTINCT tu.id, 'Carroceiria' as model, tu.body_type, tu.load_capacity
FROM trailer tu
         LEFT JOIN truck t ON tu.id = t.trailer_id
         LEFT JOIN appointments a ON t.id = a.truck_id
WHERE tu.user_id = $1
  AND (a.situation != 'em andamento' OR a.situation IS NULL)
`

type GetDashboardTrailerEnterpriseRow struct {
	ID           int64           `json:"id"`
	Model        string          `json:"model"`
	BodyType     sql.NullString  `json:"body_type"`
	LoadCapacity sql.NullFloat64 `json:"load_capacity"`
}

func (q *Queries) GetDashboardTrailerEnterprise(ctx context.Context, userID int64) ([]GetDashboardTrailerEnterpriseRow, error) {
	rows, err := q.db.QueryContext(ctx, getDashboardTrailerEnterprise, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDashboardTrailerEnterpriseRow
	for rows.Next() {
		var i GetDashboardTrailerEnterpriseRow
		if err := rows.Scan(
			&i.ID,
			&i.Model,
			&i.BodyType,
			&i.LoadCapacity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOffersForDashboard = `-- name: GetOffersForDashboard :one
SELECT
    cr.advertisement_user_id AS recipient_user_id,
    COALESCE(
            SUM(
                    CASE
                        WHEN EXTRACT(MONTH FROM cm.created_at) = EXTRACT(MONTH FROM CURRENT_DATE)
                            AND EXTRACT(YEAR FROM cm.created_at) = EXTRACT(YEAR FROM CURRENT_DATE)
                            THEN 1
                        ELSE 0
                        END
            ), 0::bigint
    )::bigint AS total_offers_mes_atual,
    COALESCE(
            SUM(
                    CASE
                        WHEN EXTRACT(MONTH FROM cm.created_at) = CASE
                                                                     WHEN EXTRACT(MONTH FROM CURRENT_DATE) = 1 THEN 12
                                                                     ELSE EXTRACT(MONTH FROM CURRENT_DATE) - 1
                            END
                            AND EXTRACT(YEAR FROM cm.created_at) = CASE
                                                                       WHEN EXTRACT(MONTH FROM CURRENT_DATE) = 1 THEN EXTRACT(YEAR FROM CURRENT_DATE) - 1
                                                                       ELSE EXTRACT(YEAR FROM CURRENT_DATE)
                                END
                            THEN 1
                        ELSE 0
                        END
            ), 0::bigint
    )::bigint AS total_offers_mes_anterior
FROM chat_messages cm
         INNER JOIN chat_rooms cr ON cm.room_id = cr.id
WHERE cm.type_message = 'offer'
  AND cr.advertisement_user_id = $1
GROUP BY cr.advertisement_user_id
`

type GetOffersForDashboardRow struct {
	RecipientUserID        int64 `json:"recipient_user_id"`
	TotalOffersMesAtual    int64 `json:"total_offers_mes_atual"`
	TotalOffersMesAnterior int64 `json:"total_offers_mes_anterior"`
}

func (q *Queries) GetOffersForDashboard(ctx context.Context, advertisementUserID int64) (GetOffersForDashboardRow, error) {
	row := q.db.QueryRowContext(ctx, getOffersForDashboard, advertisementUserID)
	var i GetOffersForDashboardRow
	err := row.Scan(&i.RecipientUserID, &i.TotalOffersMesAtual, &i.TotalOffersMesAnterior)
	return i, err
}
