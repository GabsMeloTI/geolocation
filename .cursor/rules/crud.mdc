---
description:
globs:
alwaysApply: false
---
Resumo do que farei:
Criar as queries SQL seguindo o padrão do driver.sql:
INSERT (Create)
UPDATE
DELETE LÓGICO (soft delete com status)
GET BY ID
GET ALL
Gerar o código SQLC com sqlc generate
Criar a estrutura de pastas com os 4 arquivos:
repository.go - Interface + implementação concreta
model.go - Structs de request/response + métodos de conversão
service.go - Lógica de negócio + validações
handler.go - Controle HTTP + documentação Swagger
Seguir exatamente os padrões dos arquivos anexados:
Nomenclatura consistente
Estrutura de interfaces
Métodos de conversão
Documentação Swagger
Tratamento de erros
Estou 100% preparado para:
Analisar a migration que você criar
Identificar todos os campos da tabela
Criar as queries SQL no padrão correto
Gerar o código SQLC automaticamente
Implementar todos os arquivos seguindo a arquitetura existente
Manter consistência com o resto do projeto

irei adicionar mais dois pontos para você. Após tudo isso, preciso que na pasta:
/infra

no arquivo container, você precisa adicionar dentro da struct `ContainerDI`, os campos:
*primeiro anexo(mas com o nome ideal é claro)

logo após, na funcao `buildRepository`, adicionar:
c.RepositoryRoutes = routes.NewTollsRepository(c.ConnDB)

e fazer a mesma coisa na funcao `buildService`:
c.ServiceRoutes = routes.NewRoutesService(c.RepositoryRoutes)

e na handler:
c.HandlerRoutes = routes.NewRoutesHandler(c.ServiceRoutes)

e após isso, na pasta:
/cmd

no arquivo api.go, adicionar as rotas, no padrao:
*segundo anexo

